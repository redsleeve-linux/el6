From c5161728f1f445810fd0e7630fc4c68f5c233007 Mon Sep 17 00:00:00 2001
From: Pavel Raiskup <praiskup@redhat.com>
Date: Mon, 18 Jul 2016 10:26:36 +0200
Subject: [PATCH 1/2] This is a combination of 3 commits. ==

And there is one downstream patch for API incompatibility because we
applied 3.X patch against 2.8.3 version.

== The first commit's message is: ==

Issue 175: Simplify filter bidding code.

SVN-Revision: 3663

Generated by:
git show d00167e1 libarchive/archive_read_support_filter_compress.c

== This is the 2nd commit message: ==

Issue 547:  problems with compress bidder

The code previously was not very careful about verifying the
compression parameters.  This led to cases where it failed to
reject invalid compressed data at the beginning.  The invalid
left shift was one symptom of this.

The code is now more careful:  It verifies that the compression
parameter byte exists and verifies that the maximum code size
is <= 16 bits.

This also includes some new tests to verify that truncated or
otherwise invalid compressed data is rejected.

== This is the 3rd commit message: ==

add missing tests to automake
---
 Makefile.am                                        |  1 +
 .../archive_read_support_compression_compress.c    | 25 ++++---
 libarchive/test/test_read_filter_compress.c        | 80 ++++++++++++++++++++++
 3 files changed, 96 insertions(+), 10 deletions(-)
 create mode 100644 libarchive/test/test_read_filter_compress.c

diff --git a/Makefile.am b/Makefile.am
index 61e8da4..9844b3c 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -252,6 +252,7 @@ libarchive_test_SOURCES=					\
 	libarchive/test/test_read_disk_entry_from_file.c	\
 	libarchive/test/test_read_extract.c			\
 	libarchive/test/test_read_file_nonexistent.c		\
+	libarchive/test/test_read_filter_compress.c		\
 	libarchive/test/test_read_format_ar.c			\
 	libarchive/test/test_read_format_cpio_bin.c		\
 	libarchive/test/test_read_format_cpio_bin_Z.c		\
diff --git a/libarchive/archive_read_support_compression_compress.c b/libarchive/archive_read_support_compression_compress.c
index 2461975..09a6cbd 100644
--- a/libarchive/archive_read_support_compression_compress.c
+++ b/libarchive/archive_read_support_compression_compress.c
@@ -174,23 +174,22 @@ compress_bidder_bid(struct archive_read_filter_bidder *self,
 
 	(void)self; /* UNUSED */
 
-	buffer = __archive_read_filter_ahead(filter, 2, &avail);
+	/* Shortest valid compress file is 3 bytes. */
+	buffer = __archive_read_filter_ahead(filter, 3, &avail);
 
 	if (buffer == NULL)
 		return (0);
 
 	bits_checked = 0;
-	if (buffer[0] != 037)	/* Verify first ID byte. */
+	/* First two bytes are the magic value */
+	if (buffer[0] != 0x1F || buffer[1] != 0x9D)
 		return (0);
-	bits_checked += 8;
-
-	if (buffer[1] != 0235)	/* Verify second ID byte. */
+	/* Third byte holds compression parameters. */
+	if (buffer[2] & 0x20) /* Reserved bit, must be zero. */
 		return (0);
-	bits_checked += 8;
-
-	/*
-	 * TODO: Verify more.
-	 */
+	if (buffer[2] & 0x40) /* Reserved bit, must be zero. */
+		return (0);
+	bits_checked += 18;
 
 	return (bits_checked);
 }
@@ -232,7 +231,13 @@ compress_bidder_init(struct archive_read_filter *self)
 	(void)getbits(self, 8); /* Skip first signature byte. */
 	(void)getbits(self, 8); /* Skip second signature byte. */
 
+	/* Get compression parameters. */
 	code = getbits(self, 8);
+	if ((code & 0x1f) > 16) {
+		archive_set_error(&self->archive->archive, -1,
+		    "Invalid compressed data");
+		return (ARCHIVE_FATAL);
+	}
 	state->maxcode_bits = code & 0x1f;
 	state->maxcode = (1 << state->maxcode_bits);
 	state->use_reset_code = code & 0x80;
diff --git a/libarchive/test/test_read_filter_compress.c b/libarchive/test/test_read_filter_compress.c
new file mode 100644
index 0000000..03a1d5f
--- /dev/null
+++ b/libarchive/test/test_read_filter_compress.c
@@ -0,0 +1,80 @@
+/*-
+ * Copyright (c) 2003-2008 Tim Kientzle
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "test.h"
+
+DEFINE_TEST(test_read_filter_compress_truncated)
+{
+	const char data[] = {0x1f, 0x9d};
+	struct archive *a;
+
+	assert((a = archive_read_new()) != NULL);
+	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_compress(a));
+	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));
+	assertEqualIntA(a, ARCHIVE_FATAL,
+	    archive_read_open_memory(a, data, sizeof(data)));
+
+	assertEqualInt(ARCHIVE_OK, archive_read_close(a));
+	assertEqualInt(ARCHIVE_OK, archive_read_free(a));
+}
+
+
+DEFINE_TEST(test_read_filter_compress_empty2)
+{
+	const char data[] = {0x1f, 0x9d, 0x10};
+	struct archive *a;
+	struct archive_entry *ae;
+
+	assert((a = archive_read_new()) != NULL);
+	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_compress(a));
+	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));
+	assertEqualIntA(a, ARCHIVE_OK,
+	    archive_read_open_memory(a, data, sizeof(data)));
+
+	assertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));
+
+	/* Verify that the format detection worked. */
+	assertEqualInt(archive_filter_code(a, 0), ARCHIVE_FILTER_COMPRESS);
+	assertEqualString(archive_filter_name(a, 0), "compress (.Z)");
+	assertEqualInt(archive_format(a), ARCHIVE_FORMAT_EMPTY);
+
+	assertEqualInt(ARCHIVE_OK, archive_read_close(a));
+	assertEqualInt(ARCHIVE_OK, archive_read_free(a));
+}
+
+
+DEFINE_TEST(test_read_filter_compress_invalid)
+{
+	const char data[] = {0x1f, 0x9d, 0x11};
+	struct archive *a;
+
+	assert((a = archive_read_new()) != NULL);
+	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_compress(a));
+	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));
+	assertEqualIntA(a, ARCHIVE_FATAL,
+	    archive_read_open_memory(a, data, sizeof(data)));
+
+	assertEqualInt(ARCHIVE_OK, archive_read_close(a));
+	assertEqualInt(ARCHIVE_OK, archive_read_free(a));
+}
-- 
2.7.4

From 3efc62f095768b3a92eef347d223bc013f988a18 Mon Sep 17 00:00:00 2001
From: Pavel Raiskup <praiskup@redhat.com>
Date: Mon, 18 Jul 2016 12:31:30 +0200
Subject: [PATCH 2/2] fix testsuite

---
 libarchive/test/test_read_filter_compress.c | 28 ++++++++++++++++------------
 1 file changed, 16 insertions(+), 12 deletions(-)

diff --git a/libarchive/test/test_read_filter_compress.c b/libarchive/test/test_read_filter_compress.c
index 03a1d5f..b92a944 100644
--- a/libarchive/test/test_read_filter_compress.c
+++ b/libarchive/test/test_read_filter_compress.c
@@ -26,28 +26,32 @@
 
 DEFINE_TEST(test_read_filter_compress_truncated)
 {
-	const char data[] = {0x1f, 0x9d};
+	char data[] = {0x1f, 0x9d};
 	struct archive *a;
+	struct archive_entry *ae;
 
 	assert((a = archive_read_new()) != NULL);
-	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_compress(a));
+	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_compression_compress(a));
 	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));
-	assertEqualIntA(a, ARCHIVE_FATAL,
-	    archive_read_open_memory(a, data, sizeof(data)));
+	/* this is ARCHIVE_OK because 2.8.3 does not bid the format here yet .. */
+	assertEqualIntA(a, ARCHIVE_OK, archive_read_open_memory(a, data, sizeof(data)));
+	/* .. but it must fail here */
+	assertEqualIntA(a, ARCHIVE_FATAL, archive_read_next_header(a, &ae));
+
 
 	assertEqualInt(ARCHIVE_OK, archive_read_close(a));
-	assertEqualInt(ARCHIVE_OK, archive_read_free(a));
+	assertEqualInt(ARCHIVE_OK, archive_read_finish(a));
 }
 
 
 DEFINE_TEST(test_read_filter_compress_empty2)
 {
-	const char data[] = {0x1f, 0x9d, 0x10};
+	char data[] = {0x1f, 0x9d, 0x10};
 	struct archive *a;
 	struct archive_entry *ae;
 
 	assert((a = archive_read_new()) != NULL);
-	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_compress(a));
+	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_compression_compress(a));
 	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));
 	assertEqualIntA(a, ARCHIVE_OK,
 	    archive_read_open_memory(a, data, sizeof(data)));
@@ -55,12 +59,12 @@ DEFINE_TEST(test_read_filter_compress_empty2)
 	assertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));
 
 	/* Verify that the format detection worked. */
-	assertEqualInt(archive_filter_code(a, 0), ARCHIVE_FILTER_COMPRESS);
-	assertEqualString(archive_filter_name(a, 0), "compress (.Z)");
+	assertEqualInt(archive_compression(a), ARCHIVE_COMPRESSION_COMPRESS);
+	assertEqualString(archive_compression_name(a), "compress (.Z)");
 	assertEqualInt(archive_format(a), ARCHIVE_FORMAT_EMPTY);
 
 	assertEqualInt(ARCHIVE_OK, archive_read_close(a));
-	assertEqualInt(ARCHIVE_OK, archive_read_free(a));
+	assertEqualInt(ARCHIVE_OK, archive_read_finish(a));
 }
 
 
@@ -70,11 +74,11 @@ DEFINE_TEST(test_read_filter_compress_invalid)
 	struct archive *a;
 
 	assert((a = archive_read_new()) != NULL);
-	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_compress(a));
+	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_compression_compress(a));
 	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));
 	assertEqualIntA(a, ARCHIVE_FATAL,
 	    archive_read_open_memory(a, data, sizeof(data)));
 
 	assertEqualInt(ARCHIVE_OK, archive_read_close(a));
-	assertEqualInt(ARCHIVE_OK, archive_read_free(a));
+	assertEqualInt(ARCHIVE_OK, archive_read_finish(a));
 }
-- 
2.7.4

