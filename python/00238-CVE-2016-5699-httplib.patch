From 8d74c260d4e5f97adc4236e8ea3bb7e66d018bcd Mon Sep 17 00:00:00 2001
From: Tomas Orsava <torsava@redhat.com>
Date: Mon, 4 Jul 2016 13:53:46 +0200
Subject: [PATCH] Disabled HTTP header injections in httplib

CVE-2016-5699 python: http protocol steam injection attack
rhbz#1303699 : https://bugzilla.redhat.com/show_bug.cgi?id=1303699

Based on an upstream change by Demian Brecht and Serhiy Storchaka
- in changeset 94951:1c45047c5102 2.7
- https://hg.python.org/cpython/rev/1c45047c5102
- it has been modified to work with Python 2.6
---
 Lib/httplib.py           | 37 ++++++++++++++++++++++++
 Lib/test/test_httplib.py | 74 ++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 111 insertions(+)

diff --git a/Lib/httplib.py b/Lib/httplib.py
index 7316f4c..74a3cd4 100644
--- a/Lib/httplib.py
+++ b/Lib/httplib.py
@@ -67,6 +67,7 @@ Req-sent-unread-response       _CS_REQ_SENT       <response_class>
 """
 
 from array import array
+import re
 import socket
 from sys import py3kwarning
 from urlparse import urlsplit
@@ -217,6 +218,34 @@ _MAXLINE = 65536
 # maximum amount of headers accepted
 _MAXHEADERS = 100
 
+# Header name/value ABNF (http://tools.ietf.org/html/rfc7230#section-3.2)
+#
+# VCHAR          = %x21-7E
+# obs-text       = %x80-FF
+# header-field   = field-name ":" OWS field-value OWS
+# field-name     = token
+# field-value    = *( field-content / obs-fold )
+# field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
+# field-vchar    = VCHAR / obs-text
+#
+# obs-fold       = CRLF 1*( SP / HTAB )
+#                ; obsolete line folding
+#                ; see Section 3.2.4
+
+# token          = 1*tchar
+#
+# tchar          = "!" / "#" / "$" / "%" / "&" / "'" / "*"
+#                / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
+#                / DIGIT / ALPHA
+#                ; any VCHAR, except delimiters
+#
+# VCHAR defined in http://tools.ietf.org/html/rfc5234#appendix-B.1
+
+# the patterns for both name and value are more leniant than RFC
+# definitions to allow for backwards compatibility
+_is_legal_header_name = re.compile(r'\A[^:\s][^:\r\n]*\Z').match
+_is_illegal_header_value = re.compile(r'\n(?![ \t])|\r(?![ \t\n])').search
+
 
 class HTTPMessage(mimetools.Message):
 
@@ -916,6 +945,14 @@ class HTTPConnection:
         if self.__state != _CS_REQ_STARTED:
             raise CannotSendHeader()
 
+        header = '%s' % header
+        if not _is_legal_header_name(header):
+            raise ValueError('Invalid header name %r' % (header,))
+
+        value = '%s' % value
+        if _is_illegal_header_value(value):
+            raise ValueError('Invalid header value %r' % (value,))
+
         str = '%s: %s' % (header, value)
         self._output(str)
 
diff --git a/Lib/test/test_httplib.py b/Lib/test/test_httplib.py
index 4d1a105..d6b5463 100644
--- a/Lib/test/test_httplib.py
+++ b/Lib/test/test_httplib.py
@@ -74,6 +74,80 @@ class HeaderTests(TestCase):
                 conn.request('POST', '/', body, headers)
                 self.assertEqual(conn._buffer.count[header.lower()], 1)
 
+    def test_putheader(self):
+        conn = httplib.HTTPConnection('example.com')
+        conn.sock = FakeSocket(None)
+        conn.putrequest('GET','/')
+        conn.putheader('Content-length',42)
+        self.assertTrue('Content-length: 42' in conn._buffer)
+
+        # Test for header with multiple values was removed due to
+        # putheader() only supporting one value in Python 2.6
+        conn.putheader('Foo', ' bar ')
+        self.assertTrue(b'Foo:  bar ' in conn._buffer)
+        conn.putheader('Bar', '\tbaz\t')
+        self.assertTrue(b'Bar: \tbaz\t' in conn._buffer)
+        conn.putheader('Authorization', 'Bearer mytoken')
+        self.assertTrue(b'Authorization: Bearer mytoken' in conn._buffer)
+        conn.putheader('LatinHeader', b'\xFF')
+        self.assertTrue(b'LatinHeader: \xFF' in conn._buffer)
+        conn.putheader('Utf8Header', b'\xc3\x80')
+        self.assertTrue(b'Utf8Header: \xc3\x80' in conn._buffer)
+        conn.putheader('C1-Control', b'next\x85line')
+        self.assertTrue(b'C1-Control: next\x85line' in conn._buffer)
+        conn.putheader('Embedded-Fold-Space', 'is\r\n allowed')
+        self.assertTrue(b'Embedded-Fold-Space: is\r\n allowed' in conn._buffer)
+        conn.putheader('Embedded-Fold-Tab', 'is\r\n\tallowed')
+        self.assertTrue(b'Embedded-Fold-Tab: is\r\n\tallowed' in conn._buffer)
+        conn.putheader('Key Space', 'value')
+        self.assertTrue(b'Key Space: value' in conn._buffer)
+        conn.putheader('KeySpace ', 'value')
+        self.assertTrue(b'KeySpace : value' in conn._buffer)
+        conn.putheader(b'Nonbreak\xa0Space', 'value')
+        self.assertTrue(b'Nonbreak\xa0Space: value' in conn._buffer)
+        conn.putheader(b'\xa0NonbreakSpace', 'value')
+        self.assertTrue(b'\xa0NonbreakSpace: value' in conn._buffer)
+
+    def test_invalid_headers(self):
+        conn = httplib.HTTPConnection('example.com')
+        conn.sock = FakeSocket('')
+        conn.putrequest('GET', '/')
+
+        # http://tools.ietf.org/html/rfc7230#section-3.2.4, whitespace is no
+        # longer allowed in header names
+        cases = (
+            (b'Invalid\r\nName', b'ValidValue'),
+            (b'Invalid\rName', b'ValidValue'),
+            (b'Invalid\nName', b'ValidValue'),
+            (b'\r\nInvalidName', b'ValidValue'),
+            (b'\rInvalidName', b'ValidValue'),
+            (b'\nInvalidName', b'ValidValue'),
+            (b' InvalidName', b'ValidValue'),
+            (b'\tInvalidName', b'ValidValue'),
+            (b'Invalid:Name', b'ValidValue'),
+            (b':InvalidName', b'ValidValue'),
+            (b'ValidName', b'Invalid\r\nValue'),
+            (b'ValidName', b'Invalid\rValue'),
+            (b'ValidName', b'Invalid\nValue'),
+            (b'ValidName', b'InvalidValue\r\n'),
+            (b'ValidName', b'InvalidValue\r'),
+            (b'ValidName', b'InvalidValue\n'),
+        )
+        for name, value in cases:
+            # with self.assertRaisesRegexp(ValueError, 'Invalid header'):
+            #     conn.putheader(name, value)
+
+            # assertRaisesRegexp doesn't exist in Python 2.6, therefore it has
+            # been rewritten in the form of a try/except/else block.
+            try:
+                conn.putheader(name, value)
+            except ValueError, e:
+                self.assertTrue(len(e.args) > 0 and e.args[0].startswith('Invalid header'),
+                        "ValueError has been raised does not begin with 'Invalid header'.")
+            else:
+                self.fail("ValueError for 'Invalid header' has not been raised")
+
+
 class BasicTest(TestCase):
     def test_status_lines(self):
         # Test HTTP status lines
-- 
2.9.0

