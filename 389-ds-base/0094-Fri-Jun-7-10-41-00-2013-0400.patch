From f167a9e8a462c1b5deb7e5a3c36b989672e0fd0b Mon Sep 17 00:00:00 2001
From: Mark Reynolds <mreynolds@redhat.com>
Date: Fri, 7 Jun 2013 11:15:27 -0400
Subject: [PATCH 94/99] Fri Jun 7 10:41:00 2013 -0400

    Coverity Fixes (Part 6)

    11611 - Unchecked value (main.c)
    11671 - Copy-paste error (cb_instance.c)
    11704 - Dereference after null check (repl5_replica_config.c)
    11766 - Resource leak (dblayer.c)
    11873 - Argument can not be negative (ldclt/data.c)
    Jenkins error:  mmldif.c
    11876 - Deference before null check (cl5_clcache.c)

    https://bugzilla.redhat.com/show_bug.cgi?id=970221

    Reviewed by: Rich(Thanks!)
(cherry picked from commit 4a0199b3c3a73b094a7bff64404a632c3bfe7072)
(cherry picked from commit 8212d48b57adf223c7022dba4fbdb70e7aa2080e)
---
 ldap/servers/plugins/chainingdb/cb_instance.c           |  2 +-
 ldap/servers/plugins/replication/cl5_clcache.c          |  4 +---
 ldap/servers/plugins/replication/repl5_replica_config.c |  3 ++-
 ldap/servers/slapd/back-ldbm/dblayer.c                  | 10 +++++-----
 ldap/servers/slapd/main.c                               |  7 +++++--
 ldap/servers/slapd/tools/ldclt/data.c                   | 17 ++++++++++-------
 ldap/servers/slapd/tools/mmldif.c                       |  2 +-
 7 files changed, 25 insertions(+), 20 deletions(-)

diff --git a/ldap/servers/plugins/chainingdb/cb_instance.c b/ldap/servers/plugins/chainingdb/cb_instance.c
index 8fb694a..95781b5 100644
--- a/ldap/servers/plugins/chainingdb/cb_instance.c
+++ b/ldap/servers/plugins/chainingdb/cb_instance.c
@@ -1437,7 +1437,7 @@ static int cb_instance_bindmech_set(void *arg, void *value, char *errorbuf, int
 			    charray_add(&inst->pool->waste_basket,inst->pool->mech);
 			}
 			if (inst->bind_pool->mech) {
-			    charray_add(&inst->pool->waste_basket,inst->bind_pool->mech);
+			    charray_add(&inst->bind_pool->waste_basket,inst->bind_pool->mech);
 			}
 			rc=CB_REOPEN_CONN;
 		}
diff --git a/ldap/servers/plugins/replication/cl5_clcache.c b/ldap/servers/plugins/replication/cl5_clcache.c
index 67e64f5..7a6a446 100644
--- a/ldap/servers/plugins/replication/cl5_clcache.c
+++ b/ldap/servers/plugins/replication/cl5_clcache.c
@@ -752,9 +752,7 @@ clcache_skip_change ( CLC_Buffer *buf )
 			 (csn_get_seqnum(buf->buf_current_csn) ==
 				csn_get_seqnum(cscb->local_maxcsn) + 1) )
 		{
-			if(cscb->local_maxcsn){
-				csn_init_by_csn ( cscb->local_maxcsn, buf->buf_current_csn );
-			}
+			csn_init_by_csn ( cscb->local_maxcsn, buf->buf_current_csn );
 			if(cscb->consumer_maxcsn){
 				csn_init_by_csn ( cscb->consumer_maxcsn, buf->buf_current_csn );
 			}
diff --git a/ldap/servers/plugins/replication/repl5_replica_config.c b/ldap/servers/plugins/replication/repl5_replica_config.c
index 5ca7706..0b72bec 100644
--- a/ldap/servers/plugins/replication/repl5_replica_config.c
+++ b/ldap/servers/plugins/replication/repl5_replica_config.c
@@ -2352,7 +2352,7 @@ delete_aborted_rid(Replica *r, ReplicaId rid, char *repl_root, int skip){
 static void
 delete_cleaned_rid_config(cleanruv_data *clean_data)
 {
-    Slapi_PBlock *pb = slapi_pblock_new();
+    Slapi_PBlock *pb;
     Slapi_Entry **entries = NULL;
     LDAPMod *mods[2];
     LDAPMod mod;
@@ -2381,6 +2381,7 @@ delete_cleaned_rid_config(cleanruv_data *clean_data)
     /*
      *  Search the config for the exact attribute value to delete
      */
+    pb = slapi_pblock_new();
     dn = replica_get_dn(clean_data->replica);
     slapi_search_internal_set_pb(pb, dn, LDAP_SCOPE_SUBTREE, "nsds5ReplicaCleanRUV=*", NULL, 0, NULL, NULL,
         (void *)plugin_get_default_component_id(), 0);
diff --git a/ldap/servers/slapd/back-ldbm/dblayer.c b/ldap/servers/slapd/back-ldbm/dblayer.c
index cb8ef68..fab61f3 100644
--- a/ldap/servers/slapd/back-ldbm/dblayer.c
+++ b/ldap/servers/slapd/back-ldbm/dblayer.c
@@ -2996,6 +2996,8 @@ dblayer_open_file(backend *be, char* indexname, int open_flag,
     int return_value = 0;
     DB *dbp = NULL;
     char *subname = NULL;
+    char inst_dir[MAXPATHLEN];
+    char *inst_dirp = NULL;
 
     PR_ASSERT(NULL != li);
     priv = (dblayer_private*)li->li_dblayer_private;
@@ -3059,8 +3061,6 @@ dblayer_open_file(backend *be, char* indexname, int open_flag,
                            inst->inst_parent_dir_name) > 0) &&
         !dblayer_inst_exists(inst, file_name))
     {
-        char inst_dir[MAXPATHLEN];
-        char *inst_dirp = NULL;
         char *abs_file_name = NULL;
         /* create a file with abs path, then try again */
 
@@ -3072,9 +3072,6 @@ dblayer_open_file(backend *be, char* indexname, int open_flag,
         }
         abs_file_name = slapi_ch_smprintf("%s%c%s",
                 inst_dirp, get_sep(inst_dirp), file_name);
-        if (inst_dirp != inst_dir){
-            slapi_ch_free_string(&inst_dirp);
-        }
         DB_OPEN(pENV->dblayer_openflags,
                 dbp, NULL/* txnid */, abs_file_name, subname, DB_BTREE,
                 open_flags, priv->dblayer_file_mode, return_value);
@@ -3107,6 +3104,9 @@ dblayer_open_file(backend *be, char* indexname, int open_flag,
 out:
     slapi_ch_free((void**)&file_name);
     slapi_ch_free((void**)&rel_path);
+    if (inst_dirp != inst_dir){
+        slapi_ch_free_string(&inst_dirp);
+    }
     /* close the database handle to avoid handle leak */
     if (dbp && (return_value != 0)) {
         dblayer_close_file(dbp);
diff --git a/ldap/servers/slapd/main.c b/ldap/servers/slapd/main.c
index 9938c01..53cb5c8 100644
--- a/ldap/servers/slapd/main.c
+++ b/ldap/servers/slapd/main.c
@@ -232,7 +232,10 @@ chown_dir_files(char *name, struct passwd *pw, PRBool strip_fn, PRBool both)
     if((ptr=strrchr(log,'/'))==NULL)
     {
       LDAPDebug(LDAP_DEBUG_ANY, "Caution changing ownership of ./%s \n",name,0,0);
-      slapd_chown_if_not_owner(log, pw->pw_uid, -1 ); 
+      if(slapd_chown_if_not_owner(log, pw->pw_uid, -1 )){
+          LDAPDebug(LDAP_DEBUG_ANY, "chown_dir_files: file (%s) chown failed (%d) %s.\n",
+                  log, errno, slapd_system_strerror(errno));
+      }
       rc=1;
     } else if(log==ptr) {
       LDAPDebug(LDAP_DEBUG_ANY, "Caution changing ownership of / directory and its contents to %s\n",pw->pw_name,0,0);
@@ -247,7 +250,7 @@ chown_dir_files(char *name, struct passwd *pw, PRBool strip_fn, PRBool both)
     while( (entry = PR_ReadDir(dir , PR_SKIP_BOTH )) !=NULL ) 
     {
       PR_snprintf(file,MAXPATHLEN+1,"%s/%s",log,entry->name);
-      if((rc = slapd_chown_if_not_owner( file, pw->pw_uid, both?pw->pw_gid:-1 )) != 0){
+      if(slapd_chown_if_not_owner( file, pw->pw_uid, both?pw->pw_gid:-1 )){
     	  LDAPDebug(LDAP_DEBUG_ANY, "chown_dir_files: file (%s) chown failed (%d) %s.\n",
     			  file, errno, slapd_system_strerror(errno));
       }
diff --git a/ldap/servers/slapd/tools/ldclt/data.c b/ldap/servers/slapd/tools/ldclt/data.c
index f6dd4ef..45016d8 100644
--- a/ldap/servers/slapd/tools/ldclt/data.c
+++ b/ldap/servers/slapd/tools/ldclt/data.c
@@ -143,7 +143,7 @@ int loadImages (
   char		*fileName;	/* As read from the system */
   char		 name [1024];	/* To build the full path */
   struct stat	 stat_buf;	/* To read the image size */
-  int		 fd;		/* To open the image */
+  int		 fd = -1;		/* To open the image */
   int		 ret;		/* Return value */
   int		 rc = 0;
 
@@ -303,11 +303,13 @@ int loadImages (
        */
       if (close (fd) < 0)
       {
-	perror (name);
-	fprintf (stderr, "Cannot close(%s)\n", name);
-	fflush (stderr);
-	rc = -1;
-	goto exit;
+          perror (name);
+          fprintf (stderr, "Cannot close(%s)\n", name);
+          fflush (stderr);
+          rc = -1;
+          goto exit;
+      } else {
+          fd = -1;
       }
     }
 #ifdef _WIN32
@@ -335,7 +337,8 @@ exit:
 #ifdef _WIN32
   if (findPath) free (findPath);
 #endif
-  close(fd);
+  if(fd != -1)
+      close(fd);
 
   return rc;
 }
diff --git a/ldap/servers/slapd/tools/mmldif.c b/ldap/servers/slapd/tools/mmldif.c
index fb97129..1f01976 100644
--- a/ldap/servers/slapd/tools/mmldif.c
+++ b/ldap/servers/slapd/tools/mmldif.c
@@ -729,7 +729,7 @@ readrec(edfFILE * edf1, attrib1_t ** attrib)
     int	toolong = FALSE;
     int	rc;
     int cmp;
-    attrib1_t *	att;
+    attrib1_t *	att = NULL;
     attrib1_t **	prev;
     attrib1_t *	freelist = *attrib;
     attrib1_t *	newlist = NULL;
-- 
1.8.1.4

