From 550dacd7294426e6e6f42675d6f29581cc443644 Mon Sep 17 00:00:00 2001
From: Ludwig Krispenz <lkrispen@redhat.com>
Date: Wed, 10 Sep 2014 13:22:06 +0200
Subject: [PATCH] fix for 47885 did not always return a response control

reviewd by rich, thanks

(cherry picked from commit 67e4eedad933b15837cd83fb2d0d5f5d358cddce)
---
 ldap/servers/plugins/deref/deref.c | 30 ++++++++++++------------------
 1 file changed, 12 insertions(+), 18 deletions(-)

diff --git a/ldap/servers/plugins/deref/deref.c b/ldap/servers/plugins/deref/deref.c
index 50295b9..06e2df5 100644
--- a/ldap/servers/plugins/deref/deref.c
+++ b/ldap/servers/plugins/deref/deref.c
@@ -589,14 +589,13 @@ deref_values_free(Slapi_ValueSet** results, char** actual_type_name, int buffer_
     slapi_vattr_values_free(results, actual_type_name, buffer_flags);
 }
 
-static int
+static void
 deref_do_deref_attr(Slapi_PBlock *pb, BerElement *ctrlber, const char *derefdn, const char *derefattr, const char **attrs)
 {
     char **retattrs = NULL;
     Slapi_PBlock *derefpb = NULL;
     Slapi_Entry **entries = NULL;
     int rc;
-    int needcontrol = 0;
 
 /*  If the access check on the attributes is done without retrieveing the entry
  *  it cannot handle acis which need teh entry, eg to apply a targetfilter rule
@@ -626,7 +625,6 @@ deref_do_deref_attr(Slapi_PBlock *pb, BerElement *ctrlber, const char *derefdn,
                              "The client does not have permission to read the requested "
                              "attributes in entry %s\n", derefdn);
                 } else {
-		    needcontrol = 1;
                     ber_printf(ctrlber, "{ss", derefattr, derefdn); /* begin DerefRes + derefAttr + derefVal */
                     for (ii = 0; retattrs[ii]; ++ii) {
                         Slapi_Value *sv;
@@ -701,7 +699,6 @@ deref_do_deref_attr(Slapi_PBlock *pb, BerElement *ctrlber, const char *derefdn,
     slapi_pblock_destroy(derefpb);
     slapi_ch_free((void **)&retattrs); /* retattrs does not own the strings */
 
-    return needcontrol;
 }
 
 static int
@@ -715,7 +712,6 @@ deref_pre_entry(Slapi_PBlock *pb)
     LDAPControl *ctrl = NULL;
     const LDAPControl **searchctrls = NULL;
     LDAPControl **newsearchctrls = NULL;
-    int needcontrol = 0;
 
     if (!speclist) {
         return 0; /* nothing to do */
@@ -759,25 +755,23 @@ deref_pre_entry(Slapi_PBlock *pb)
         for (; results && sv; idx = slapi_valueset_next_value(results, idx, &sv)) {
             const char *derefdn = slapi_value_get_string(sv);
 
-            needcontrol += deref_do_deref_attr(pb, ctrlber, derefdn, spec->derefattr,  (const char **)spec->attrs);
+            deref_do_deref_attr(pb, ctrlber, derefdn, spec->derefattr,  (const char **)spec->attrs);
         }
         deref_values_free(&results, &actual_type_name, buffer_flags);
     }
 
     ber_printf(ctrlber, "}"); /* end control val */
  
-    if (needcontrol) {
-        slapi_build_control(LDAP_CONTROL_X_DEREF, ctrlber, 0, &ctrl);
-        /* get the list of controls */
-	slapi_pblock_get(pb, SLAPI_SEARCH_CTRLS, &searchctrls);
-        /* dup them */
-        slapi_add_controls(&newsearchctrls, (LDAPControl **)searchctrls, 1);
-        /* add our control */
-        slapi_add_control_ext(&newsearchctrls, ctrl, 0);
-        ctrl = NULL; /* newsearchctrls owns it now */
-        /* set the controls in the pblock */
-        slapi_pblock_set(pb, SLAPI_SEARCH_CTRLS, newsearchctrls);
-    }
+    slapi_build_control(LDAP_CONTROL_X_DEREF, ctrlber, 0, &ctrl);
+    /* get the list of controls */
+    slapi_pblock_get(pb, SLAPI_SEARCH_CTRLS, &searchctrls);
+    /* dup them */
+    slapi_add_controls(&newsearchctrls, (LDAPControl **)searchctrls, 1);
+    /* add our control */
+    slapi_add_control_ext(&newsearchctrls, ctrl, 0);
+    ctrl = NULL; /* newsearchctrls owns it now */
+    /* set the controls in the pblock */
+    slapi_pblock_set(pb, SLAPI_SEARCH_CTRLS, newsearchctrls);
     ber_free(ctrlber, 1);
 
     return 0;
-- 
1.9.3

