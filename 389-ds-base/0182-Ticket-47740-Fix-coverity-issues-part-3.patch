From d02be8587d411b75e8b72c5830528641007cc15a Mon Sep 17 00:00:00 2001
From: Mark Reynolds <mreynolds@redhat.com>
Date: Wed, 12 Mar 2014 14:38:50 -0400
Subject: [PATCH 182/225] Ticket 47740 - Fix coverity issues - part 3

12504 - resource leak - /ldap/servers/slapd/back-ldbm/import-threads.c
12499 - resource leak - /ldap/servers/slapd/passwd_extop.c
12497 - resource leak - /ldap/servers/slapd/mapping_tree.c
12496 - resource leak - /ldap/servers/slapd/mapping_tree.c
12495 - resource leak - /ldap/servers/plugins/replication/legacy_consumer.c
12493 - resource leak - /ldap/servers/slapd/tools/rsearch/sdattable.c
12492 - resource leak - /ldap/servers/slapd/tools/pwenc.c
12491 - resource leak - /ldap/servers/slapd/tools/mmldif.c

https://fedorahosted.org/389/ticket/47740

Reviewed by: rmeggins(Thanks!)
(cherry picked from commit ff78177452f1ac3da6039640815cc2eaf55b0b40)
(cherry picked from commit 2b9788b7d282b055b6f1945eb3f3b5c784d779fc)
(cherry picked from commit fd8668bcf47935a4fb90d782badf6c8bf07f6c94)
---
 ldap/servers/plugins/replication/legacy_consumer.c | 10 ++--
 ldap/servers/slapd/back-ldbm/import-threads.c      |  1 +
 ldap/servers/slapd/mapping_tree.c                  | 16 ++++++
 ldap/servers/slapd/passwd_extop.c                  |  4 +-
 ldap/servers/slapd/tools/mmldif.c                  |  2 +
 ldap/servers/slapd/tools/pwenc.c                   |  4 +-
 ldap/servers/slapd/tools/rsearch/sdattable.c       | 58 ++++++++++++++--------
 7 files changed, 65 insertions(+), 30 deletions(-)

diff --git a/ldap/servers/plugins/replication/legacy_consumer.c b/ldap/servers/plugins/replication/legacy_consumer.c
index 2440ce7..aa5a9b5 100644
--- a/ldap/servers/plugins/replication/legacy_consumer.c
+++ b/ldap/servers/plugins/replication/legacy_consumer.c
@@ -371,11 +371,12 @@ legacy_consumer_config_modify (Slapi_PBlock *pb, Slapi_Entry* entryBefore, Slapi
                 {
                     if (mod_type == LDAP_MOD_REPLACE)
                     {
+                        slapi_ch_free_string(&legacy_consumer_replicationpw);
                         legacy_consumer_replicationpw = config_copy_strval(config_attr_value);
                     }
                     else if (mod_type == LDAP_MOD_DELETE)
                     {
-                        legacy_consumer_replicationpw = NULL;
+                        slapi_ch_free_string(&legacy_consumer_replicationpw);
                     }
                     else if (mod_type == LDAP_MOD_ADD)
                     {
@@ -387,6 +388,7 @@ legacy_consumer_config_modify (Slapi_PBlock *pb, Slapi_Entry* entryBefore, Slapi
                         }
                         else
                         {
+                            slapi_ch_free_string(&legacy_consumer_replicationpw);
                             legacy_consumer_replicationpw = config_copy_strval(config_attr_value);
                         }
                     }
@@ -419,11 +421,8 @@ legacy_consumer_config_delete (Slapi_PBlock *pb, Slapi_Entry* e, Slapi_Entry* en
 	slapi_rwlock_wrlock (legacy_consumer_config_lock);
     if (legacy_consumer_replicationdn)
         slapi_sdn_free (&legacy_consumer_replicationdn);
-    if (legacy_consumer_replicationpw)
-        slapi_ch_free ((void**)&legacy_consumer_replicationpw);
-
+    slapi_ch_free_string(&legacy_consumer_replicationpw);
 	legacy_consumer_replicationdn = NULL;
-    legacy_consumer_replicationpw = NULL;
 	slapi_rwlock_unlock (legacy_consumer_config_lock);
 
 	*returncode = LDAP_SUCCESS;
@@ -446,6 +445,7 @@ legacy_consumer_extract_config(Slapi_Entry* entry, char *returntext)
 	    legacy_consumer_replicationdn = slapi_sdn_new_dn_passin (arg);
 
     arg= slapi_entry_attr_get_charptr(entry,CONFIG_LEGACY_REPLICATIONPW_ATTRIBUTE);
+    slapi_ch_free_string(&legacy_consumer_replicationpw);
     legacy_consumer_replicationpw = arg;
 
 	slapi_rwlock_unlock (legacy_consumer_config_lock);
diff --git a/ldap/servers/slapd/back-ldbm/import-threads.c b/ldap/servers/slapd/back-ldbm/import-threads.c
index c7d3444..d30936e 100644
--- a/ldap/servers/slapd/back-ldbm/import-threads.c
+++ b/ldap/servers/slapd/back-ldbm/import-threads.c
@@ -2256,6 +2256,7 @@ import_foreman(void *param)
                                             "of the duplicated entry %s; "
                                             "Entry ID: %d", 
                                             orig_dn, fi->entry->ep_id);
+                    slapi_ch_free_string(&orig_dn);
                     goto cont;
                 }
                 new_entrydn = slapi_attr_new();
diff --git a/ldap/servers/slapd/mapping_tree.c b/ldap/servers/slapd/mapping_tree.c
index 19c5708..12d9205 100644
--- a/ldap/servers/slapd/mapping_tree.c
+++ b/ldap/servers/slapd/mapping_tree.c
@@ -1110,6 +1110,8 @@ int mapping_tree_entry_modify_callback(Slapi_PBlock *pb, Slapi_Entry* entryBefor
                           "Error: could not find parent for %s\n",
                           slapi_entry_get_dn(entryAfter), 0, 0);
                     slapi_sdn_free(&subtree);
+                    slapi_ch_free_string(&plugin_fct);
+                    slapi_ch_free_string(&plugin_lib);
                     *returncode = LDAP_UNWILLING_TO_PERFORM;
                     return SLAPI_DSE_CALLBACK_ERROR;
                 }
@@ -1148,6 +1150,8 @@ int mapping_tree_entry_modify_callback(Slapi_PBlock *pb, Slapi_Entry* entryBefor
             {
                 free_mapping_tree_node_arrays(&backends, &be_names, &be_states, &be_list_count);
                 slapi_sdn_free(&subtree);
+                slapi_ch_free_string(&plugin_fct);
+                slapi_ch_free_string(&plugin_lib);
                 *returncode = LDAP_UNWILLING_TO_PERFORM;
                 return SLAPI_DSE_CALLBACK_ERROR;
             }
@@ -1161,6 +1165,8 @@ int mapping_tree_entry_modify_callback(Slapi_PBlock *pb, Slapi_Entry* entryBefor
                 mtn_unlock();
                 free_mapping_tree_node_arrays(&backends, &be_names, &be_states, &be_list_count);
                 slapi_sdn_free(&subtree);
+                slapi_ch_free_string(&plugin_fct);
+                slapi_ch_free_string(&plugin_lib);
                 return SLAPI_DSE_CALLBACK_ERROR;
             }
 
@@ -1189,12 +1195,16 @@ int mapping_tree_entry_modify_callback(Slapi_PBlock *pb, Slapi_Entry* entryBefor
                 PR_snprintf(returntext, SLAPI_DSE_RETURNTEXT_SIZE, "must use replace operation to change state\n");
                 *returncode = LDAP_UNWILLING_TO_PERFORM;
                 slapi_sdn_free(&subtree);
+                slapi_ch_free_string(&plugin_fct);
+                slapi_ch_free_string(&plugin_lib);
                 return SLAPI_DSE_CALLBACK_ERROR;
             }
             if ((mods[i]->mod_bvalues == NULL) || (mods[i]->mod_bvalues[0] == NULL))
             {
                 slapi_sdn_free(&subtree);
                 *returncode = LDAP_OPERATIONS_ERROR;
+                slapi_ch_free_string(&plugin_fct);
+                slapi_ch_free_string(&plugin_lib);
                 return SLAPI_DSE_CALLBACK_ERROR;
             }
 
@@ -1208,6 +1218,8 @@ int mapping_tree_entry_modify_callback(Slapi_PBlock *pb, Slapi_Entry* entryBefor
                 {
                     PR_snprintf(returntext, SLAPI_DSE_RETURNTEXT_SIZE, "need to set nsslapd-backend before moving to backend state\n");
                     slapi_sdn_free(&subtree);
+                    slapi_ch_free_string(&plugin_fct);
+                    slapi_ch_free_string(&plugin_lib);
                     *returncode = LDAP_UNWILLING_TO_PERFORM;
                     return SLAPI_DSE_CALLBACK_ERROR;
                 }
@@ -1220,6 +1232,8 @@ int mapping_tree_entry_modify_callback(Slapi_PBlock *pb, Slapi_Entry* entryBefor
                 {
                     PR_snprintf(returntext, SLAPI_DSE_RETURNTEXT_SIZE, "need to set nsslapd-referral before moving to referral state\n");
                     slapi_sdn_free(&subtree);
+                    slapi_ch_free_string(&plugin_fct);
+                    slapi_ch_free_string(&plugin_lib);
                     *returncode = LDAP_UNWILLING_TO_PERFORM;
                     return SLAPI_DSE_CALLBACK_ERROR;
                 }
@@ -1258,6 +1272,8 @@ int mapping_tree_entry_modify_callback(Slapi_PBlock *pb, Slapi_Entry* entryBefor
                     *returncode = LDAP_UNWILLING_TO_PERFORM;
                     mtn_unlock();
                     slapi_sdn_free(&subtree);
+                    slapi_ch_free_string(&plugin_fct);
+                    slapi_ch_free_string(&plugin_lib);
                     return SLAPI_DSE_CALLBACK_ERROR;
                 }
 
diff --git a/ldap/servers/slapd/passwd_extop.c b/ldap/servers/slapd/passwd_extop.c
index 4aebee3..9ad470f 100644
--- a/ldap/servers/slapd/passwd_extop.c
+++ b/ldap/servers/slapd/passwd_extop.c
@@ -905,7 +905,6 @@ static char *passwd_name_list[] = {
 int passwd_modify_init( Slapi_PBlock *pb )
 {
 	char	**argv;
-	char	*oid;
 
 	/* Get the arguments appended to the plugin extendedop directive. The first argument 
 	 * (after the standard arguments for the directive) should contain the OID of the
@@ -924,9 +923,8 @@ int passwd_modify_init( Slapi_PBlock *pb )
 				 "OID is missing or is not %s\n", EXTOP_PASSWD_OID );
 		return( -1 );
 	} else {
-		oid = slapi_ch_strdup( argv[0] );
 		slapi_log_error( SLAPI_LOG_PLUGIN, "passwd_modify_init", 
-				 "Registering plug-in for Password Modify extended op %s.\n", oid );
+				 "Registering plug-in for Password Modify extended op %s.\n", argv[0] /* oid */);
 	}
 
 	/* Register the plug-in function as an extended operation
diff --git a/ldap/servers/slapd/tools/mmldif.c b/ldap/servers/slapd/tools/mmldif.c
index 1f01976..4213e65 100644
--- a/ldap/servers/slapd/tools/mmldif.c
+++ b/ldap/servers/slapd/tools/mmldif.c
@@ -659,6 +659,7 @@ int mm_init(int argc, char * argv[])
             slapd_ldap_debug = 65535;
             break;
         case 'o':
+            if(ofn) free (ofn);
             ofn = strdup(optarg);
             break;
         case 'h':
@@ -677,6 +678,7 @@ int mm_init(int argc, char * argv[])
         ofp = fopen(ofn, "w");
         if (ofp == NULL) {
             perror(ofn);
+            free(ofn);
             return -1;
         }
         free(ofn);
diff --git a/ldap/servers/slapd/tools/pwenc.c b/ldap/servers/slapd/tools/pwenc.c
index 221398c..34cfe1b 100644
--- a/ldap/servers/slapd/tools/pwenc.c
+++ b/ldap/servers/slapd/tools/pwenc.c
@@ -140,8 +140,10 @@ init_config(char *configdir)
 
     abs_configdir = rel2abspath( configdir );
     if ( config_set_configdir( "configdir (-D)", abs_configdir,
-                               errorbuf, 1) != LDAP_SUCCESS ) {
+                               errorbuf, 1) != LDAP_SUCCESS )
+    {
         fprintf( stderr, "%s\n", errorbuf );
+        slapi_ch_free_string(&abs_configdir);
         return( NULL );
     }
     slapi_ch_free_string(&abs_configdir);
diff --git a/ldap/servers/slapd/tools/rsearch/sdattable.c b/ldap/servers/slapd/tools/rsearch/sdattable.c
index c0274d0..18417a1 100644
--- a/ldap/servers/slapd/tools/rsearch/sdattable.c
+++ b/ldap/servers/slapd/tools/rsearch/sdattable.c
@@ -141,27 +141,43 @@ int sdt_load(SDatTable *sdt, const char *filename)
     if (!fd) return 0;
 
     while (PR_Available(fd) > 0) {
-	int rval;
-	char temp[256];
-	char *dn = NULL;
-	char *uid = NULL;
-	while (!(rval = PR_GetLine(fd, temp, 256))) {
-	    char *p;
-	    if (!strncasecmp(temp, "dn:", 3)) {
-		for (p = temp + 4; *p == ' ' || *p == '\t'; p++) ;
-	        dn = strdup(p);
-	        if (!dn) break;
-	    } else if (!strncasecmp(temp, "uid:", 4)) {
-		for (p = temp + 5; *p == ' ' || *p == '\t'; p++) ;
-	        uid = strdup(p);
-	        if (!uid) break;
-	    }
-	    if (uid) {	/* dn should come earlier than uid */
-	        if (!sdt_push(sdt, dn, uid)) goto out;
-		break;
-	    }
-	}
-	if (rval) break;	/* PR_GetLine failed */
+		int rval;
+		int pushed = 0;
+		char temp[256];
+		char *dn = NULL;
+		char *uid = NULL;
+		while (!(rval = PR_GetLine(fd, temp, 256))) {
+			char *p;
+			if (!strncasecmp(temp, "dn:", 3)) {
+				for (p = temp + 4; *p == ' ' || *p == '\t'; p++) ;
+				dn = strdup(p);
+				if (!dn) break;
+			} else if (!strncasecmp(temp, "uid:", 4)) {
+				for (p = temp + 5; *p == ' ' || *p == '\t'; p++) ;
+				uid = strdup(p);
+				if (!uid) break;
+			}
+			if (uid) {
+				/* dn should come earlier than uid - so both dn and uid must be set. */
+				if (!sdt_push(sdt, dn, uid)){
+					/* failure, free the dn and uid */
+					free(dn);
+					free(uid);
+					goto out;
+				}
+				pushed = 1;
+				break;
+			}
+		}
+		if(!pushed){
+			/*
+			 * Entry might not have been a user entry with a uid,
+			 * so free the dn just in case.
+			 */
+			if(dn)
+				free(dn);
+		}
+		if (rval) break;	/* PR_GetLine failed */
     }
 out:
     PR_Close(fd);
-- 
1.8.1.4

