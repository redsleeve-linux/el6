From 9b723851da58c9dc651de9b81b8beed58bff803e Mon Sep 17 00:00:00 2001
From: Noriko Hosoi <nhosoi@totoro.usersys.redhat.com>
Date: Tue, 5 Feb 2013 14:56:12 -0800
Subject: [PATCH 30/33] Ticket 570 - DS returns error 20 when replacing values
 of a multi-valued attribute  (only when replication
 is enabled)

Bug Description:  When replacing an attr value "SOME_VALUE" with "some_value", and replication
                  is enabled, an error 20(type or value exists) is incorrectly returned.

Fix Description:  For replace operations we were doing a bit-by-bit comparison.  Ignoring the syntax
                  of the attribute.  The fix was to remove this bit-by-bit check that is no longer
                  necessary with the current code base.

https://fedorahosted.org/389/ticket/570

Reviewed by: ?
(cherry picked and fixed conflicts from commit 1c3bf98303c04323542251f1c564c8bdc4e8cc67)
---
 ldap/servers/slapd/attr.c     |   95 ++++++++++++++---------------------------
 ldap/servers/slapd/entrywsi.c |    2 +-
 ldap/servers/slapd/slap.h     |    1 -
 3 files changed, 33 insertions(+), 65 deletions(-)

diff --git a/ldap/servers/slapd/attr.c b/ldap/servers/slapd/attr.c
index 2dc2a80..87dfe1e 100644
--- a/ldap/servers/slapd/attr.c
+++ b/ldap/servers/slapd/attr.c
@@ -534,76 +534,45 @@ slapi_attr_flag_is_set( const Slapi_Attr *a, unsigned long flag )
 int
 slapi_attr_value_cmp( const Slapi_Attr *a, const struct berval *v1, const struct berval *v2 )
 {
-	int retVal;
+    Slapi_Attr a2 = *a;
+    struct ava ava;
+    Slapi_Value *cvals[2];
+    Slapi_Value tmpcval;
 
-	if ( a->a_flags & SLAPI_ATTR_FLAG_CMP_BITBYBIT )
-	{
-		int cmplen = ( v1->bv_len <= v2->bv_len ? v1->bv_len : v2->bv_len );
-		retVal = memcmp(v1->bv_val, v2->bv_val, cmplen);
-		if ( retVal == 0 && v1->bv_len < v2->bv_len )
-		{
-			retVal = -1;
-		}
-		else if ( retVal == 0 && v1->bv_len > v2->bv_len )
-		{
-			retVal = 1;
-		}
-	}
-	else
-	{
-		Slapi_Attr a2;
-		struct ava ava;
-		Slapi_Value *cvals[2];
-		Slapi_Value tmpcval;
-
-		a2 = *a;
-		cvals[0] = &tmpcval;
-		cvals[0]->v_csnset = NULL;
-		cvals[0]->bv = *v1;
-		cvals[0]->v_flags = 0;
-		cvals[1] = NULL;
-		a2.a_present_values.va = cvals; /* JCM - PUKE */
-		ava.ava_type = a->a_type;
-		ava.ava_value = *v2;
-		ava.ava_private = NULL;
-		retVal = plugin_call_syntax_filter_ava(&a2, LDAP_FILTER_EQUALITY, &ava);
-	}
-	return retVal;
+    cvals[0] = &tmpcval;
+    cvals[0]->v_csnset = NULL;
+    cvals[0]->bv = *v1;
+    cvals[0]->v_flags = 0;
+    cvals[1] = NULL;
+    a2.a_present_values.va = cvals; /* JCM - PUKE */
+    ava.ava_type = a->a_type;
+    ava.ava_value = *v2;
+    ava.ava_private = NULL;
+
+    return( plugin_call_syntax_filter_ava(&a2, LDAP_FILTER_EQUALITY, &ava));
 }
 
 int
 slapi_attr_value_cmp_ext(const Slapi_Attr *a, Slapi_Value *v1, Slapi_Value *v2)
 {
-	int retVal;
-	const struct berval *bv2 = slapi_value_get_berval(v2);
+    struct ava ava;
+    Slapi_Attr a2 = *a;
+    Slapi_Value *cvals[2];
+    unsigned long v2_flags = v2->v_flags;
+    const struct berval *bv2 = slapi_value_get_berval(v2);
+
+    cvals[0] = v1;
+    cvals[1] = NULL;
+    a2.a_present_values.va = cvals;
+    ava.ava_type = a->a_type;
+    ava.ava_value = *bv2;
+    if (v2_flags) {
+        ava.ava_private = &v2_flags;
+    } else {
+        ava.ava_private = NULL;
+    }
 
-	if ( a->a_flags & SLAPI_ATTR_FLAG_CMP_BITBYBIT )
-	{
-		const struct berval *bv1 = slapi_value_get_berval(v1);
-		return slapi_attr_value_cmp(a, bv1, bv2);
-	}
-	else
-	{
-		Slapi_Attr a2;
-		struct ava ava;
-		Slapi_Value *cvals[2];
-		unsigned long v2_flags = v2->v_flags;
-
-		a2 = *a;
-		cvals[0] = v1;
-		cvals[1] = NULL;
-		a2.a_present_values.va = cvals; /* JCM - PUKE */
-
-		ava.ava_type = a->a_type;
-		ava.ava_value = *bv2;
-		if (v2_flags) {
-			ava.ava_private = &v2_flags;
-		} else {
-			ava.ava_private = NULL;
-		}
-		retVal = plugin_call_syntax_filter_ava(&a2, LDAP_FILTER_EQUALITY, &ava);
-	}
-	return retVal;
+    return (plugin_call_syntax_filter_ava(&a2, LDAP_FILTER_EQUALITY, &ava));
 }
 
 /*
diff --git a/ldap/servers/slapd/entrywsi.c b/ldap/servers/slapd/entrywsi.c
index 0419864..971e9e3 100644
--- a/ldap/servers/slapd/entrywsi.c
+++ b/ldap/servers/slapd/entrywsi.c
@@ -709,7 +709,7 @@ entry_replace_present_values_wsi(Slapi_Entry *e, const char *type, struct berval
 	 * slapi_entry_add_values() returns LDAP_SUCCESS and so the
 	 * attribute remains deleted (which is the correct outcome).
 	 */
-	return( entry_add_present_values_wsi( e, type, vals, csn, urp, SLAPI_ATTR_FLAG_CMP_BITBYBIT ));
+	return( entry_add_present_values_wsi( e, type, vals, csn, urp, 0));
 }
 
 /*
diff --git a/ldap/servers/slapd/slap.h b/ldap/servers/slapd/slap.h
index e3cbc72..eea025a 100644
--- a/ldap/servers/slapd/slap.h
+++ b/ldap/servers/slapd/slap.h
@@ -510,7 +510,6 @@ typedef struct asyntaxinfo {
 											   if any */
 #define SLAPI_ATTR_FLAG_NOLOCKING	0x0020	/* the init code doesn't lock the
 											   tables */
-#define SLAPI_ATTR_FLAG_CMP_BITBYBIT	0x4000	/* do memcmp, not syntax cmp */
 #define SLAPI_ATTR_FLAG_KEEP		0x8000 /* keep when replacing all */
 
 /* This is the type of the function passed into attr_syntax_enumerate_attrs */
-- 
1.7.7.6

