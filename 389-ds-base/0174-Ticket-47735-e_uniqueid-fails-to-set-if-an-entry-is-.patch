From 68973758cc835199facd97620bcbb368eca358a8 Mon Sep 17 00:00:00 2001
From: Noriko Hosoi <nhosoi@redhat.com>
Date: Fri, 7 Mar 2014 12:29:55 -0800
Subject: [PATCH 174/225] Ticket #47735 - e_uniqueid fails to set if an entry
 is a conflict entry

Bug Description:
When an entry is turned to be a conflict entry, its nsUniqueId has
a mdcsn info as a subtype like this:
 nsUniqueId;mdcsn-5319136f000200010000: c5e0d787-a58f11e3-b7f9dfd1-acc3d5e4
In this case, the attribute type is assigned to the berval "type"
as follows:
 type.bv_val = "nsUniqueId;mdcsn-5319136f000200010000"
 type.bv_len = 37
The subtyped stateinfo is processed in str2entry_state_information_from_type,
which modifies type.bv_val to "nsUniqueId", but type.bv_len remains 37.
str2entry_fast has this logic to set e_uniqueid, where the nsUniqueId
with stateinfo fails to set the value to e_uniqueid.
 if ( type.bv_len == 10 &&
      PL_strncasecmp (type.bv_val, "nsUniqueId", type.bv_len) == 0 ){

Fix Description: This patch resets the length of the type with the
basetype length 10 before the if expression is called for setting
e_uniqueid.

https://fedorahosted.org/389/ticket/47735

Reviewed by rmeggins@redhat.com (Thank you, Rich!!)
(cherry picked from commit a02f94191f38f46eff4f777083b5a50624d46a89)
(cherry picked from commit 6153865313beaff49bde969d71d72fa0e80c3c1f)
(cherry picked from commit e1f92c03b03f22ec4533d777413b9437eb9cb81c)
---
 ldap/servers/slapd/entry.c | 43 ++++++++++++++++++++++++++++---------------
 1 file changed, 28 insertions(+), 15 deletions(-)

diff --git a/ldap/servers/slapd/entry.c b/ldap/servers/slapd/entry.c
index 8a5df7e..97d21a6 100644
--- a/ldap/servers/slapd/entry.c
+++ b/ldap/servers/slapd/entry.c
@@ -85,10 +85,22 @@ static char *forbidden_attrs [] = {PSEUDO_ATTR_UNHASHEDUSERPASSWORD,
 /*
  * WARNING: s gets butchered... the base type remains.
  */
-void
-str2entry_state_information_from_type(char *s,CSNSet **csnset,CSN **attributedeletioncsn,CSN **maxcsn,int *value_state,int *attr_state)
-{
-	char *p= strchr(s, ';');
+static void
+str2entry_state_information_from_type(struct berval *atype,
+                                      CSNSet **csnset,
+                                      CSN **attributedeletioncsn,
+                                      CSN **maxcsn,
+                                      int *value_state,
+                                      int *attr_state)
+{
+	char *p = NULL;
+	if ((NULL == atype) || (NULL == atype->bv_val)) {
+		return;
+	}
+	p = PL_strchr(atype->bv_val, ';');
+	if (p) {
+		atype->bv_len = p - atype->bv_val;
+	}
 	*value_state= VALUE_PRESENT;
 	*attr_state= ATTRIBUTE_PRESENT;
 	while(p!=NULL)
@@ -229,19 +241,20 @@ str2entry_fast( const char *rawdn, char *s, int flags, int read_stateinfo )
 		}
 
 		if ( slapi_ldif_parse_line( s, &type, &value, &freeval ) < 0 ) {
-			LDAPDebug( LDAP_DEBUG_TRACE,
-			    "<= str2entry_fast NULL (parse_line)\n", 0, 0, 0 );
+			LDAPDebug0Args(LDAP_DEBUG_TRACE, "<= str2entry_fast NULL (parse_line)\n");
 			continue;
 		}
 
 		/*
 		 * Extract the attribute and value CSNs from the attribute type.
-		 */		
+		 */
 		csn_free(&attributedeletioncsn); /* JCM - Do this more efficiently */
 		csnset_free(&valuecsnset);
 		value_state= VALUE_NOTFOUND;
 		attr_state= ATTRIBUTE_NOTFOUND;
-		str2entry_state_information_from_type(type.bv_val,&valuecsnset,&attributedeletioncsn,&maxcsn,&value_state,&attr_state);
+		str2entry_state_information_from_type(&type,
+		                                      &valuecsnset, &attributedeletioncsn,
+		                                      &maxcsn, &value_state, &attr_state);
 		if(!read_stateinfo)
 		{
 			/* We are not maintaining state information */
@@ -376,8 +389,7 @@ str2entry_fast( const char *rawdn, char *s, int flags, int read_stateinfo )
 		}
 
 		/* retrieve uniqueid */
-		if ( type.bv_len == SLAPI_ATTR_UNIQUEID_LENGTH && PL_strncasecmp (type.bv_val, SLAPI_ATTR_UNIQUEID, type.bv_len) == 0 ){
-
+		if ((type.bv_len == SLAPI_ATTR_UNIQUEID_LENGTH) && (PL_strcasecmp (type.bv_val, SLAPI_ATTR_UNIQUEID) == 0)) {
 			if (e->e_uniqueid != NULL){
 				LDAPDebug (LDAP_DEBUG_TRACE, 
 						   "str2entry_fast: entry has multiple uniqueids %s "
@@ -733,7 +745,7 @@ str2entry_dupcheck( const char *rawdn, char *s, int flags, int read_stateinfo )
     entry_attrs *ea = NULL;
     int tree_attr_checking = 0;
     int big_entry_attr_presence_check = 0;
-    int check_for_duplicate_values = (0 != (flags & SLAPI_STR2ENTRY_REMOVEDUPVALS));
+    int check_for_duplicate_values = ( 0 != ( flags & SLAPI_STR2ENTRY_REMOVEDUPVALS ));
     Slapi_Value *value = 0;
     CSN *attributedeletioncsn= NULL;
     CSNSet *valuecsnset= NULL;
@@ -744,7 +756,7 @@ str2entry_dupcheck( const char *rawdn, char *s, int flags, int read_stateinfo )
     /* Check if we should be performing strict validation. */
     strict = config_get_dn_validate_strict();
 
-    LDAPDebug( LDAP_DEBUG_TRACE, "=> str2entry_dupcheck\n", 0, 0, 0 );
+    LDAPDebug0Args(LDAP_DEBUG_TRACE, "=> str2entry_dupcheck\n");
 
     e = slapi_entry_alloc();
     slapi_entry_init(e,NULL,NULL);
@@ -784,7 +796,9 @@ str2entry_dupcheck( const char *rawdn, char *s, int flags, int read_stateinfo )
 		csnset_free(&valuecsnset);
 		value_state= VALUE_NOTFOUND;
 		attr_state= VALUE_NOTFOUND;
-		str2entry_state_information_from_type(type,&valuecsnset,&attributedeletioncsn,&maxcsn,&value_state,&attr_state);
+		str2entry_state_information_from_type(&bvtype,
+		                                      &valuecsnset, &attributedeletioncsn,
+		                                      &maxcsn, &value_state, &attr_state);
 		if(!read_stateinfo)
 		{
 			/* We are not maintaining state information */
@@ -892,8 +906,7 @@ str2entry_dupcheck( const char *rawdn, char *s, int flags, int read_stateinfo )
 		}
 
 		/* retrieve uniqueid */
-		if ( strcasecmp (type, SLAPI_ATTR_UNIQUEID) == 0 ){
-
+		if ((bvtype.bv_len == SLAPI_ATTR_UNIQUEID_LENGTH) && (PL_strcasecmp (type, SLAPI_ATTR_UNIQUEID) == 0)) {
 			if (e->e_uniqueid != NULL){
 				LDAPDebug (LDAP_DEBUG_TRACE, 
 						   "str2entry_dupcheck: entry has multiple uniqueids %s "
-- 
1.8.1.4

