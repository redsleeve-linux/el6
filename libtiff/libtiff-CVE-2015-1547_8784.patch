From ff605ace566cc87d7023716f9f94e199c5614e01 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Nikola=20Forr=C3=B3?= <nforro@redhat.com>
Date: Wed, 20 Jul 2016 12:07:22 +0200
Subject: [PATCH] Fix CVE-2015-1547 and CVE-2015-8784

---
 libtiff/tif_next.c | 15 ++++++++++++---
 1 file changed, 12 insertions(+), 3 deletions(-)

diff --git a/libtiff/tif_next.c b/libtiff/tif_next.c
index 9ff2f04..56909f3 100644
--- a/libtiff/tif_next.c
+++ b/libtiff/tif_next.c
@@ -37,7 +37,7 @@
 	case 0:	op[0]  = (unsigned char) ((v) << 6); break;	\
 	case 1:	op[0] |= (v) << 4; break;	\
 	case 2:	op[0] |= (v) << 2; break;	\
-	case 3:	*op++ |= (v);	   break;	\
+	case 3:	*op++ |= (v); op_offset++; break;	\
 	}					\
 }
 
@@ -48,6 +48,7 @@
 static int
 NeXTDecode(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s)
 {
+	static const char module[] = "NeXTDecode";
 	unsigned char *bp, *op;
 	tsize_t cc;
 	tidata_t row;
@@ -101,6 +102,8 @@ NeXTDecode(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s)
             if( isTiled(tif) )
                 imagewidth = tif->tif_dir.td_tilewidth;
 
+            tsize_t op_offset = 0;
+
 			/*
 			 * The scanline is composed of a sequence of constant
 			 * color ``runs''.  We shift into ``run mode'' and
@@ -116,14 +119,19 @@ NeXTDecode(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s)
 				 * bounds, potentially resulting in a security
 				 * issue.
 				 */
-				while (n-- > 0 && npixels < imagewidth)
+				while (n-- > 0 && npixels < imagewidth && op_offset < scanline)
 					SETPIXEL(op, grey);
 				if (npixels >= imagewidth)
 					break;
+                if (op_offset >= scanline ) {
+                    TIFFErrorExt(tif->tif_clientdata, module, "Invalid data for scanline %ld",
+                            (long) tif->tif_row);
+                    return (0);
+                }
 				if (cc == 0)
 					goto bad;
 				n = *bp++, cc--;
-			}
+            }
 			break;
 		}
 		}
@@ -137,6 +145,7 @@ bad:
 	return (0);
 }
 
+
 static int
 NeXTPreDecode(TIFF* tif, uint16 s)
 {
-- 
2.7.4

