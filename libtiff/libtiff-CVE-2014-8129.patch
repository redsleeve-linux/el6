From f3c061cf64c0cd927e72966e3fc92c2c54107187 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Nikola=20Forr=C3=B3?= <nforro@redhat.com>
Date: Wed, 20 Jul 2016 12:48:10 +0200
Subject: [PATCH] Fix CVE-2014-8129

---
 libtiff/tif_dir.c      | 20 ++++++++++++++++++--
 libtiff/tif_dirread.c  | 48 +++++++++++++++++++++++++++++++++---------------
 libtiff/tif_getimage.c | 15 +++++++++++++++
 libtiff/tif_next.c     | 19 +++++++++++++++++++
 tools/tiff2pdf.c       | 41 +++++++++++++++++++++++++++++++++++++++++
 tools/tiffcrop.c       |  7 ++++---
 6 files changed, 130 insertions(+), 20 deletions(-)

diff --git a/libtiff/tif_dir.c b/libtiff/tif_dir.c
index bb5386a..a4c8845 100644
--- a/libtiff/tif_dir.c
+++ b/libtiff/tif_dir.c
@@ -141,6 +141,7 @@ _TIFFVSetField(TIFF* tif, ttag_t tag, va_list ap)
 	TIFFDirectory* td = &tif->tif_dir;
 	int status = 1;
 	uint32 v32, i, v;
+    double dblval;
 	char* s;
 
 	switch (tag) {
@@ -245,10 +246,16 @@ _TIFFVSetField(TIFF* tif, ttag_t tag, va_list ap)
 		td->td_smaxsamplevalue = va_arg(ap, double);
 		break;
 	case TIFFTAG_XRESOLUTION:
-		td->td_xresolution = (float) va_arg(ap, double);
+        dblval = va_arg(ap, double);
+        if( dblval < 0 )
+            goto badvaluedouble;
+		td->td_xresolution = (float) dblval;
 		break;
 	case TIFFTAG_YRESOLUTION:
-		td->td_yresolution = (float) va_arg(ap, double);
+        dblval = va_arg(ap, double);
+        if( dblval < 0 )
+            goto badvaluedouble;
+		td->td_yresolution = (float) dblval;
 		break;
 	case TIFFTAG_PLANARCONFIG:
 		v = va_arg(ap, uint32);
@@ -598,6 +605,15 @@ badvalue32:
 		     _TIFFFieldWithTag(tif, tag)->field_name);
 	va_end(ap);
 	return (0);
+badvaluedouble:
+        {
+        TIFFErrorExt(tif->tif_clientdata, module,
+             "%s: Bad value %f for \"%s\" tag",
+             tif->tif_name, dblval,
+		     _TIFFFieldWithTag(tif, tag)->field_name);
+        va_end(ap);
+        }
+    return (0);
 }
 
 /*
diff --git a/libtiff/tif_dirread.c b/libtiff/tif_dirread.c
index 0a9484d..b78bd96 100644
--- a/libtiff/tif_dirread.c
+++ b/libtiff/tif_dirread.c
@@ -86,6 +86,7 @@ TIFFReadDirectory(TIFF* tif)
 	uint16 previous_tag = 0;
 	int diroutoforderwarning = 0, compressionknown = 0;
 	int haveunknowntags = 0;
+    int bitspersample_read = FALSE;
 
 	tif->tif_diroff = tif->tif_nextdiroff;
 	/*
@@ -449,21 +450,25 @@ TIFFReadDirectory(TIFF* tif)
 			 * BitsPerSample and friends, and we will read this
 			 * too.
 			 */
-			if (dp->tdir_count == 1) {
-				v = TIFFExtractData(tif,
-				    dp->tdir_type, dp->tdir_offset);
-				if (!TIFFSetField(tif, dp->tdir_tag, (uint16)v))
-					goto bad;
-			/* XXX: workaround for broken TIFFs */
-			} else if (dp->tdir_tag == TIFFTAG_BITSPERSAMPLE
-				   && dp->tdir_type == TIFF_LONG) {
-				if (!TIFFFetchPerSampleLongs(tif, dp, &v) ||
-				    !TIFFSetField(tif, dp->tdir_tag, (uint16)v))
-					goto bad;
-			} else {
-				if (!TIFFFetchPerSampleShorts(tif, dp, &iv) ||
-				    !TIFFSetField(tif, dp->tdir_tag, iv))
-					goto bad;
+			{
+				if (dp->tdir_count == 1) {
+					v = TIFFExtractData(tif,
+					    dp->tdir_type, dp->tdir_offset);
+					if (!TIFFSetField(tif, dp->tdir_tag, (uint16)v))
+						goto bad;
+				/* XXX: workaround for broken TIFFs */
+				} else if (dp->tdir_tag == TIFFTAG_BITSPERSAMPLE
+					   && dp->tdir_type == TIFF_LONG) {
+					if (!TIFFFetchPerSampleLongs(tif, dp, &v) ||
+					    !TIFFSetField(tif, dp->tdir_tag, (uint16)v))
+						goto bad;
+				} else {
+					if (!TIFFFetchPerSampleShorts(tif, dp, &iv) ||
+					    !TIFFSetField(tif, dp->tdir_tag, iv))
+						goto bad;
+				}
+				if( dp->tdir_tag == TIFFTAG_BITSPERSAMPLE )
+    	        	bitspersample_read = TRUE;
 			}
 			break;
 		case TIFFTAG_SMINSAMPLEVALUE:
@@ -491,6 +496,19 @@ TIFFReadDirectory(TIFF* tif)
 		case TIFFTAG_TRANSFERFUNCTION:
 			{
 				char* cp;
+				/* It would be dangerous to instanciate those tag values */
+				/* since if td_bitspersample has not yet been read (due to */
+				/* unordered tags), it could be read afterwards with a */
+				/* values greater than the default one (1), which may cause */
+				/* crashes in user code */
+				if( !bitspersample_read )
+				{
+					fip = TIFFFieldWithTag(tif,dp->tdir_tag);
+					TIFFWarningExt(tif->tif_clientdata,module,
+						"Ignoring %s since BitsPerSample tag not found",
+						fip ? fip->field_name : "unknown tagname");
+					continue;
+				}
 				/*
 				 * TransferFunction can have either 1x or 3x
 				 * data values; Colormap can have only 3x
diff --git a/libtiff/tif_getimage.c b/libtiff/tif_getimage.c
index 6db0a4b..c654c6b 100644
--- a/libtiff/tif_getimage.c
+++ b/libtiff/tif_getimage.c
@@ -178,8 +178,23 @@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
 				    "Planarconfiguration", td->td_planarconfig);
 				return (0);
 			}
+			if( td->td_samplesperpixel != 3 )
+            {
+                sprintf(emsg,
+                        "Sorry, can not handle image with %s=%d",
+                        "Samples/pixel", td->td_samplesperpixel);
+                return 0;
+            }
 			break;
 		case PHOTOMETRIC_CIELAB:
+            if( td->td_samplesperpixel != 3 || td->td_bitspersample != 8 )
+            {
+                sprintf(emsg,
+                        "Sorry, can not handle image with %s=%d and %s=%d",
+                        "Samples/pixel", td->td_samplesperpixel,
+                        "Bits/sample", td->td_bitspersample);
+                return 0;
+            }
 			break;
 		default:
 			sprintf(emsg, "Sorry, can not handle image with %s=%d",
diff --git a/libtiff/tif_next.c b/libtiff/tif_next.c
index d7652bb..ceb8989 100644
--- a/libtiff/tif_next.c
+++ b/libtiff/tif_next.c
@@ -96,6 +96,8 @@ NeXTDecode(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s)
 		default: {
 			uint32 npixels = 0, grey;
 			uint32 imagewidth = tif->tif_dir.td_imagewidth;
+            if( isTiled(tif) )
+                imagewidth = tif->tif_dir.td_tilewidth;
 
 			/*
 			 * The scanline is composed of a sequence of constant
@@ -133,10 +135,27 @@ bad:
 	return (0);
 }
 
+static int
+NeXTPreDecode(TIFF* tif, uint16 s)
+{
+	static const char module[] = "NeXTPreDecode";
+	TIFFDirectory *td = &tif->tif_dir;
+	(void)s;
+
+	if( td->td_bitspersample != 2 )
+	{
+		TIFFErrorExt(tif->tif_clientdata, module, "Unsupported BitsPerSample = %d",
+					 td->td_bitspersample);
+		return (0);
+	}
+	return (1);
+}
+	
 int
 TIFFInitNeXT(TIFF* tif, int scheme)
 {
 	(void) scheme;
+	tif->tif_predecode = NeXTPreDecode;  
 	tif->tif_decoderow = NeXTDecode;
 	tif->tif_decodestrip = NeXTDecode;
 	tif->tif_decodetile = NeXTDecode;
diff --git a/tools/tiff2pdf.c b/tools/tiff2pdf.c
index ac5d70d..b726942 100644
--- a/tools/tiff2pdf.c
+++ b/tools/tiff2pdf.c
@@ -1218,6 +1218,15 @@ void t2p_read_tiff_init(T2P* t2p, TIFF* input){
 		if( (TIFFGetField(input, TIFFTAG_PLANARCONFIG, &xuint16) != 0)
 			&& (xuint16 == PLANARCONFIG_SEPARATE ) ){
 				TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &xuint16);
+                if( (t2p->tiff_tiles[i].tiles_tilecount % xuint16) != 0 )
+                {
+                    TIFFError(
+                        TIFF2PDF_MODULE, 
+                        "Invalid tile count, %s", 
+                        TIFFFileName(input));
+                    t2p->t2p_error = T2P_ERR_ERROR;
+                    return;
+                }
 				t2p->tiff_tiles[i].tiles_tilecount/= xuint16;
 		}
 		if( t2p->tiff_tiles[i].tiles_tilecount > 0){
@@ -1598,6 +1607,22 @@ void t2p_read_tiff_data(T2P* t2p, TIFF* input){
 #endif
 			break;
 		case PHOTOMETRIC_CIELAB:
+            if( t2p->tiff_samplesperpixel != 3){
+                TIFFError(
+                    TIFF2PDF_MODULE, 
+                    "Unsupported samplesperpixel = %d for CIELAB", 
+                    t2p->tiff_samplesperpixel);
+                t2p->t2p_error = T2P_ERR_ERROR;
+                return;
+            }
+            if( t2p->tiff_bitspersample != 8){
+                TIFFError(
+                    TIFF2PDF_MODULE, 
+                    "Invalid bitspersample = %d for CIELAB", 
+                    t2p->tiff_bitspersample);
+                t2p->t2p_error = T2P_ERR_ERROR;
+                return;
+            }
 			t2p->pdf_labrange[0]= -127;
 			t2p->pdf_labrange[1]= 127;
 			t2p->pdf_labrange[2]= -127;
@@ -1613,6 +1638,22 @@ void t2p_read_tiff_data(T2P* t2p, TIFF* input){
 			t2p->pdf_colorspace=T2P_CS_LAB;
 			break;
 		case PHOTOMETRIC_ITULAB:
+            if( t2p->tiff_samplesperpixel != 3){
+                TIFFError(
+                    TIFF2PDF_MODULE, 
+                    "Unsupported samplesperpixel = %d for ITULAB", 
+                    t2p->tiff_samplesperpixel);
+                t2p->t2p_error = T2P_ERR_ERROR;
+                return;
+            }
+            if( t2p->tiff_bitspersample != 8){
+                TIFFError(
+                    TIFF2PDF_MODULE, 
+                    "Invalid bitspersample = %d for ITULAB", 
+                    t2p->tiff_bitspersample);
+                t2p->t2p_error = T2P_ERR_ERROR;
+                return;
+            }
 			t2p->pdf_labrange[0]=-85;
 			t2p->pdf_labrange[1]=85;
 			t2p->pdf_labrange[2]=-75;
diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index 7684318..9edff96 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -1193,9 +1193,10 @@ static int writeBufferToContigTiles (TIFF* out, uint8* buf, uint32 imagelength,
   tsize_t tilesize = TIFFTileSize(out);
   unsigned char *tilebuf = NULL;
 
-  TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);
-  TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);
-  TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);
+  if( !TIFFGetField(out, TIFFTAG_TILELENGTH, &tl) ||
+      !TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw) ||
+      !TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps) )
+      return 1;
 
   tile_buffsize = tilesize;
   if (tilesize < (tsize_t)(tl * tile_rowsize))
-- 
2.7.4

