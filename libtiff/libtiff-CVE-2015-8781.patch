diff --git a/libtiff/tif_luv.c b/libtiff/tif_luv.c
index eb622b9..d4d9d10 100644
--- a/libtiff/tif_luv.c
+++ b/libtiff/tif_luv.c
@@ -183,6 +183,7 @@ struct logLuvState {
 static int
 LogL16Decode(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
 {
+    static const char module [] = "LogL16Decode";
 	LogLuvState* sp = DecoderState(tif);
 	int shft, i, npixels;
 	unsigned char* bp;
@@ -198,7 +199,11 @@ LogL16Decode(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
 	if (sp->user_datafmt == SGILOGDATAFMT_16BIT)
 		tp = (int16*) op;
 	else {
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                    "Translation buffer too short");
+            return (0);
+        }
 		tp = (int16*) sp->tbuf;
 	}
 	_TIFFmemset((tdata_t) tp, 0, npixels*sizeof (tp[0]));
@@ -207,7 +212,7 @@ LogL16Decode(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
 	cc = tif->tif_rawcc;
 					/* get each byte string */
 	for (shft = 2*8; (shft -= 8) >= 0; ) {
-		for (i = 0; i < npixels && cc > 0; )
+		for (i = 0; i < npixels && cc > 0; ) {
 			if (*bp >= 128) {		/* run */
 				rc = *bp++ + (2-128);
 				b = (int16)(*bp++ << shft);
@@ -219,6 +224,7 @@ LogL16Decode(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
 				while (--cc && rc-- && i < npixels)
 					tp[i++] |= (int16)*bp++ << shft;
 			}
+        }
 		if (i != npixels) {
 			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
 		"LogL16Decode: Not enough data at row %d (short %d pixels)",
@@ -240,6 +246,7 @@ LogL16Decode(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
 static int
 LogLuvDecode24(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
 {
+    static const char module [] = "LogLuvDecode24";
 	LogLuvState* sp = DecoderState(tif);
 	int cc, i, npixels;
 	unsigned char* bp;
@@ -253,13 +260,17 @@ LogLuvDecode24(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
 	if (sp->user_datafmt == SGILOGDATAFMT_RAW)
 		tp = (uint32 *)op;
 	else {
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                    "Translation buffer too short");
+            return (0);
+        }
 		tp = (uint32 *) sp->tbuf;
 	}
 					/* copy to array of uint32 */
 	bp = (unsigned char*) tif->tif_rawcp;
 	cc = tif->tif_rawcc;
-	for (i = 0; i < npixels && cc > 0; i++) {
+	for (i = 0; i < npixels && cc >= 3; i++) {
 		tp[i] = bp[0] << 16 | bp[1] << 8 | bp[2];
 		bp += 3;
 		cc -= 3;
@@ -282,6 +293,7 @@ LogLuvDecode24(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
 static int
 LogLuvDecode32(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
 {
+    static const char module [] = "LogLuvDecode32";
 	LogLuvState* sp;
 	int shft, i, npixels;
 	unsigned char* bp;
@@ -298,7 +310,11 @@ LogLuvDecode32(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
 	if (sp->user_datafmt == SGILOGDATAFMT_RAW)
 		tp = (uint32*) op;
 	else {
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                    "Translation buffer too short");
+            return (0);
+        }
 		tp = (uint32*) sp->tbuf;
 	}
 	_TIFFmemset((tdata_t) tp, 0, npixels*sizeof (tp[0]));
@@ -307,8 +323,10 @@ LogLuvDecode32(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
 	cc = tif->tif_rawcc;
 					/* get each byte string */
 	for (shft = 4*8; (shft -= 8) >= 0; ) {
-		for (i = 0; i < npixels && cc > 0; )
+		for (i = 0; i < npixels && cc > 0; ) {
 			if (*bp >= 128) {		/* run */
+                if ( cc < 2 )
+                    break;
 				rc = *bp++ + (2-128);
 				b = (uint32)*bp++ << shft;
 				cc -= 2;
@@ -319,6 +337,7 @@ LogLuvDecode32(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
 				while (--cc && rc-- && i < npixels)
 					tp[i++] |= (uint32)*bp++ << shft;
 			}
+        }
 		if (i != npixels) {
 			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
 		"LogLuvDecode32: Not enough data at row %d (short %d pixels)",
@@ -372,6 +391,7 @@ LogLuvDecodeTile(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
 static int
 LogL16Encode(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
 {
+    static const char module [] = "LogL16Encode";
 	LogLuvState* sp = EncoderState(tif);
 	int shft, i, j, npixels;
 	tidata_t op;
@@ -387,7 +407,11 @@ LogL16Encode(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
 		tp = (int16*) bp;
 	else {
 		tp = (int16*) sp->tbuf;
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                    "Translation buffer too short");
+            return (0);
+        }
 		(*sp->tfunc)(sp, bp, npixels);
 	}
 					/* compress each byte string */
@@ -460,6 +484,7 @@ LogL16Encode(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
 static int
 LogLuvEncode24(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
 {
+    static const char module [] = "LogLuvEncode24";
 	LogLuvState* sp = EncoderState(tif);
 	int i, npixels, occ;
 	tidata_t op;
@@ -473,7 +498,11 @@ LogLuvEncode24(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
 		tp = (uint32*) bp;
 	else {
 		tp = (uint32*) sp->tbuf;
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                    "Translation buffer too short");
+            return (0);
+        }
 		(*sp->tfunc)(sp, bp, npixels);
 	}
 					/* write out encoded pixels */
@@ -505,6 +534,7 @@ LogLuvEncode24(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
 static int
 LogLuvEncode32(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
 {
+    static const char module [] = "LogLuvEncode32";
 	LogLuvState* sp = EncoderState(tif);
 	int shft, i, j, npixels;
 	tidata_t op;
@@ -521,7 +551,11 @@ LogLuvEncode32(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
 		tp = (uint32*) bp;
 	else {
 		tp = (uint32*) sp->tbuf;
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+            TIFFErrorExt(tif->tif_clientdata, module,
+                    "Translation buffer too short");
+            return (0);
+        }
 		(*sp->tfunc)(sp, bp, npixels);
 	}
 					/* compress each byte string */
